name: CI/CD Simulation with ArgoCD Image Updater

on:
  push:
    branches: [main]

jobs:
  deploy-simulation:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      # 1. Checkout repository
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      # 2. Configure Git
      - name: Configure Git
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com

      # 3. Install tools
      - name: Install kubectl, kind, helm
        run: |
          curl -sLo kubectl https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          curl -sLo kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x kind && sudo mv kind /usr/local/bin/
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      # 4. Create Kind cluster
      - name: Create Kind cluster
        run: kind create cluster --name argocd-cluster

      # 5. Install ArgoCD
      - name: Install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-repo-server -n argocd

      # 6. Install ArgoCD Image Updater
      - name: Install ArgoCD Image Updater
        run: |
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj-labs/argocd-image-updater/master/manifests/install.yaml
          kubectl wait --for=condition=available --timeout=180s deployment/argocd-image-updater -n argocd

      # 7. Create target namespace
      - name: Create helms namespace
        run: kubectl create namespace helms || true

      # 8. Apply ArgoCD Application
      - name: Apply Application manifest
        run: |
          kubectl apply -f - <<EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: weather-app
            namespace: argocd
            annotations:
              argocd-image-updater.argoproj.io/image-list: weather-app=docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app
              argocd-image-updater.argoproj.io/weather-app.update-strategy: latest
              argocd-image-updater.argoproj.io/write-back-method: git
          spec:
            project: default
            source:
              repoURL: https://github.com/${{ github.repository }}
              targetRevision: main
              path: weather-app-helms
              helm:
                valueFiles: ["values.yaml"]
            destination:
              server: https://kubernetes.default.svc
              namespace: helms
            syncPolicy:
              automated: {}
          EOF

      # # 9. Wait for initial application sync
      # - name: Wait for initial application sync
      #   run: |
      #     echo "Waiting for application 'weather-app' to become Healthy..."
      #     end_time=$((SECONDS + 300))
      #     while [ $SECONDS -lt $end_time ]; do
      #       status=$(kubectl get application weather-app -n argocd -o jsonpath='{.status.sync.status},{.status.health.status}' 2>/dev/null || echo "Unknown,Unknown")
      #       sync_status=$(echo $status | cut -d',' -f1)
      #       health_status=$(echo $status | cut -d',' -f2)
            
      #       if [ "$sync_status" = "Synced" ] && [ "$health_status" = "Healthy" ]; then
      #         echo "‚úÖ Application is Synced and Healthy!"
      #         exit 0
      #       else
      #         echo "Current status: Sync=$sync_status, Health=$health_status. Waiting..."
      #         sleep 10
      #       fi
      #     done
      #     echo "‚ùå Timed out waiting for application to become Healthy."
      #     kubectl describe application weather-app -n argocd
      #     exit 1


      - name: Wait for initial application sync
        run: |
          echo "Waiting for application 'weather-app' to become Synced..."
          end_time=$((SECONDS + 300))
          while [ $SECONDS -lt $end_time ]; do
            sync_status=$(kubectl get application weather-app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            
            if [ "$sync_status" = "Synced" ]; then
              echo "‚úÖ Application is Synced! Proceeding with simulation."
              # Check health status but don't fail if it's still Progressing
              health_status=$(kubectl get application weather-app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
              echo "Health status: $health_status"
              exit 0
            else
              echo "Current sync status: $sync_status. Waiting..."
              sleep 10
            fi
          done
          echo "‚ö†Ô∏è Timed out waiting for application to sync, but proceeding anyway for testing."
          echo "This might indicate issues with the deployment that will be visible later."

      # 10. Docker login
      - name: Docker login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 11. Build and push images
      - name: Build & Push Images
        run: |
          docker build -t docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:good -f Dockerfile.good .
          docker push docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:good
          docker build -t docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:bad -f Dockerfile.bad .
          docker push docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:bad

      # # 12. Trigger Image Updater via Git changes (Good ‚Üí Bad ‚Üí Good)
      # - name: Trigger Image Updater via Git changes
      #   run: |
      #     for TAG in good bad good; do
      #       echo "‚û°Ô∏è Deploying image tag: $TAG"
            
      #       # Pull latest changes first
      #       git pull origin main
            
      #       # Update values.yaml with the new tag
      #       sed -i 's/tag:.*/tag: "'$TAG'"/' weather-app-helms/values.yaml
            
      #       # Commit and push to trigger ArgoCD sync
      #       git add weather-app-helms/values.yaml
      #       git commit -m "Deploy $TAG image via CI" || echo "No changes to commit"
      #       git push origin main
            
      #       # Wait for reconciliation
      #       TIMEOUT=300
      #       INTERVAL=10
      #       ELAPSED=0
      #       while true; do
      #         CURRENT=$(kubectl get deployment weather-app -n helms -o jsonpath="{.spec.template.spec.containers[0].image}" 2>/dev/null || echo "")
      #         if [[ "$CURRENT" == *":$TAG" ]]; then
      #           echo "‚úÖ Image reconciled to $TAG"
      #           break
      #         fi
      #         if [[ $ELAPSED -ge $TIMEOUT ]]; then
      #           echo "‚ùå Timeout waiting for $TAG deployment"
      #           kubectl describe deployment weather-app -n helms
      #           exit 1
      #         fi
      #         echo "Waiting for $TAG deployment... (Current: $CURRENT)"
      #         sleep $INTERVAL
      #         ELAPSED=$((ELAPSED + INTERVAL))
      #       done
            
      #       # Additional wait for bad image to fail (if it's the bad tag)
      #       if [[ "$TAG" == "bad" ]]; then
      #         echo "‚è≥ Waiting for bad image to fail..."
      #         # Wait for deployment to become unavailable
      #         FAIL_TIMEOUT=120
      #         FAIL_ELAPSED=0
      #         while true; do
      #           AVAILABLE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.status.conditions[?(@.type=='Available')].status}" 2>/dev/null || echo "Unknown")
      #           if [[ "$AVAILABLE" == "False" ]]; then
      #             echo "‚úÖ Bad image deployment failed as expected"
      #             break
      #           fi
      #           if [[ $FAIL_ELAPSED -ge $FAIL_TIMEOUT ]]; then
      #             echo "‚ùå Expected bad image to fail but it didn't"
      #             kubectl describe deployment weather-app -n helms
      #             exit 1
      #           fi
      #           sleep 5
      #           FAIL_ELAPSED=$((FAIL_ELAPSED + 5))
      #         done
      #       fi
      #     done

      # SECOND
      # - name: Trigger deployment via Git changes
      #   run: |
      #     for TAG in good bad good; do
      #       echo "‚û°Ô∏è Deploying image tag: $TAG"
            
      #       # Pull latest changes
      #       git pull origin main
            
      #       # Update values.yaml
      #       sed -i 's/tag:.*/tag: "'$TAG'"/' weather-app-helms/values.yaml
            
      #       # Commit and push
      #       git add weather-app-helms/values.yaml
      #       git commit -m "Deploy $TAG image" || echo "No changes to commit"
      #       git push origin main
            
      #       # Wait for ArgoCD to detect Git change and sync
      #       echo "‚è≥ Waiting for ArgoCD to detect Git change and sync..."
      #       TIMEOUT=180
      #       INTERVAL=10
      #       ELAPSED=0
      #       while true; do
      #         SYNC_STATUS=$(kubectl get application weather-app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
      #         if [ "$SYNC_STATUS" = "Synced" ]; then
      #           echo "‚úÖ ArgoCD has synced the application"
      #           break
      #         fi
      #         if [[ $ELAPSED -ge $TIMEOUT ]]; then
      #           echo "‚ùå Timeout waiting for ArgoCD sync"
      #           exit 1
      #         fi
      #         sleep $INTERVAL
      #         ELAPSED=$((ELAPSED + INTERVAL))
      #       done
            
      #       # Wait for deployment to update
      #       echo "‚è≥ Waiting for deployment to update to $TAG..."
      #       TIMEOUT=300
      #       INTERVAL=10
      #       ELAPSED=0
      #       while true; do
      #         CURRENT=$(kubectl get deployment weather-app -n helms -o jsonpath="{.spec.template.spec.containers[0].image}" 2>/dev/null || echo "")
      #         if [[ "$CURRENT" == *":$TAG" ]]; then
      #           echo "‚úÖ Deployment updated to $TAG"
      #           break
      #         fi
      #         if [[ $ELAPSED -ge $TIMEOUT ]]; then
      #           echo "‚ö†Ô∏è Timeout waiting for $TAG deployment - checking if rollback is needed"
                
      #           # If bad image failed, manually trigger rollback to good
      #           if [[ "$TAG" == "bad" ]]; then
      #             echo "üîÑ Bad image failed - manually rolling back to good..."
      #             git pull origin main
      #             sed -i 's/tag:.*/tag: "good"/' weather-app-helms/values.yaml
      #             git add weather-app-helms/values.yaml
      #             git commit -m "Rollback to good image after bad deployment failed"
      #             git push origin main
      #             break
      #           else
      #             echo "‚ùå Timeout waiting for $TAG deployment"
      #             kubectl describe deployment weather-app -n helms
      #             exit 1
      #           fi
      #         fi
      #         echo "Waiting for $TAG deployment... (Current: $CURRENT)"
      #         sleep $INTERVAL
      #         ELAPSED=$((ELAPSED + INTERVAL))
      #       done
            
      #       # Additional logic for bad image
      #       if [[ "$TAG" == "bad" ]]; then
      #         echo "‚è≥ Waiting for bad image to fail..."
      #         FAIL_TIMEOUT=120
      #         FAIL_ELAPSED=0
      #         while true; do
      #           AVAILABLE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.status.conditions[?(@.type=='Available')].status}" 2>/dev/null || echo "Unknown")
      #           if [[ "$AVAILABLE" == "False" ]]; then
      #             echo "‚úÖ Bad image deployment failed as expected"
      #             break
      #           fi
      #           if [[ $FAIL_ELAPSED -ge $FAIL_TIMEOUT ]]; then
      #             echo "‚ùå Expected bad image to fail but it didn't"
      #             kubectl describe deployment weather-app -n helms
      #             exit 1
      #           fi
      #           sleep 5
      #           FAIL_ELAPSED=$((FAIL_ELAPSED + 5))
      #         done
      #       fi
      #     done

      - name: Trigger deployment via Git changes
        run: |
          for TAG in good bad good; do
            echo "‚û°Ô∏è Deploying image tag: $TAG"
            
            # Pull latest changes
            git pull origin main
            
            # Update values.yaml
            sed -i 's/tag:.*/tag: "'$TAG'"/' weather-app-helms/values.yaml
            
            # Commit and push
            git add weather-app-helms/values.yaml
            git commit -m "Deploy $TAG image" || echo "No changes to commit"
            git push origin main
            
            # Wait for ArgoCD sync
            echo "‚è≥ Waiting for ArgoCD to detect Git change and sync..."
            TIMEOUT=180
            INTERVAL=10
            ELAPSED=0
            while true; do
              SYNC_STATUS=$(kubectl get application weather-app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
              if [ "$SYNC_STATUS" = "Synced" ]; then
                echo "‚úÖ ArgoCD has synced the application"
                break
              fi
              if [[ $ELAPSED -ge $TIMEOUT ]]; then
                echo "‚ùå Timeout waiting for ArgoCD sync"
                exit 1
              fi
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done
            
            # Wait for deployment to update
            echo "‚è≥ Waiting for deployment to update to $TAG..."
            TIMEOUT=300
            INTERVAL=10
            ELAPSED=0
            while true; do
              CURRENT=$(kubectl get deployment weather-app -n helms -o jsonpath="{.spec.template.spec.containers[0].image}" 2>/dev/null || echo "")
              if [[ "$CURRENT" == *":$TAG" ]]; then
                echo "‚úÖ Deployment updated to $TAG"
                break
              fi
              if [[ $ELAPSED -ge $TIMEOUT ]]; then
                echo "‚ùå Timeout waiting for $TAG deployment"
                kubectl describe deployment weather-app -n helms
                exit 1
              fi
              echo "Waiting for $TAG deployment... (Current: $CURRENT)"
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done
            
            # Additional logic for bad image - check if it actually fails
            if [[ "$TAG" == "bad" ]]; then
              echo "‚è≥ Waiting to see if bad image fails..."
              FAIL_TIMEOUT=120
              FAIL_ELAPSED=0
              while true; do
                # Check multiple failure conditions
                AVAILABLE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.status.availableReplicas}" 2>/dev/null || echo "0")
                READY=$(kubectl get deployment weather-app -n helms -o jsonpath="{.status.readyReplicas}" 2>/dev/null || echo "0")
                UNAVAILABLE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.status.unavailableReplicas}" 2>/dev/null || echo "0")
                
                echo "Available: $AVAILABLE, Ready: $READY, Unavailable: $UNAVAILABLE"
                
                # If we have unavailable replicas or available replicas dropped, the bad image failed
                if [[ "$UNAVAILABLE" -gt 0 ]] || [[ "$AVAILABLE" -eq 0 ]]; then
                  echo "‚úÖ Bad image deployment failed as expected"
                  break
                fi
                
                if [[ $FAIL_ELAPSED -ge $FAIL_TIMEOUT ]]; then
                  echo "‚ùå Expected bad image to fail but it's running successfully!"
                  echo "Your 'bad' image is actually working correctly. It needs to fail on startup."
                  kubectl describe deployment weather-app -n helms
                  kubectl get pods -n helms
                  kubectl logs -n helms -l app=weather-app --tail=20
                  exit 1
                fi
                sleep 5
                FAIL_ELAPSED=$((FAIL_ELAPSED + 5))
              done
              
              # If bad image failed, manually rollback to good
              echo "üîÑ Bad image failed - rolling back to good..."
              git pull origin main
              sed -i 's/tag:.*/tag: "good"/' weather-app-helms/values.yaml
              git add weather-app-helms/values.yaml
              git commit -m "Rollback to good image after bad deployment failed"
              git push origin main
              
              # Wait for rollback to complete
              echo "‚è≥ Waiting for rollback to good image..."
              sleep 60
            fi
          done

          
      # 13. Verify final deployment
      - name: Verify final deployment
        run: |
          FINAL_IMAGE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.spec.template.spec.containers[0].image}")
          echo "Final deployed image: $FINAL_IMAGE"
          if [[ "$FINAL_IMAGE" == *":good" ]]; then
            echo "‚úÖ ArgoCD Image Updater successfully reconciled back to good image!"
          else
            echo "‚ùå Reconciliation failed! Expected '*:good', got: $FINAL_IMAGE"
            kubectl describe deployment weather-app -n helms
            exit 1
          fi

      # 14. Cleanup
      - name: Cleanup Kind cluster
        if: always()
        run: kind delete cluster --name argocd-cluster || true




