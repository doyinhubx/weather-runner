name: CI/CD Simulation with ArgoCD Image Updater

on:
  push:
    branches: [main]

jobs:
  deploy-simulation:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      # 1. Checkout repository
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      # 2. Configure Git
      - name: Configure Git
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com

      # 3. Install tools
      - name: Install kubectl, kind, helm
        run: |
          curl -sLo kubectl https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          curl -sLo kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          chmod +x kind && sudo mv kind /usr/local/bin/
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      # 4. Create Kind cluster
      - name: Create Kind cluster
        run: kind create cluster --name argocd-cluster

      # 5. Install ArgoCD
      - name: Install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-repo-server -n argocd

      # 6. Install ArgoCD Image Updater
      - name: Install ArgoCD Image Updater
        run: |
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj-labs/argocd-image-updater/master/manifests/install.yaml
          kubectl wait --for=condition=available --timeout=180s deployment/argocd-image-updater -n argocd

      # 7. Create target namespace
      - name: Create helms namespace
        run: kubectl create namespace helms || true

      # 8. Configure Image Updater Git credentials
      - name: Configure Image Updater Git credentials
        run: |
          kubectl create secret generic image-updater-git-creds \
            --namespace=argocd \
            --from-literal=username=github-actions \
            --from-literal=password=${{ secrets.GH_TOKEN }} \
            --dry-run=client -o yaml | kubectl apply -f -

      # 9. Apply ArgoCD Application with CORRECT Image Updater config
      - name: Apply Application manifest
        run: |
          kubectl apply -f - <<EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: weather-app
            namespace: argocd
            annotations:
              argocd-image-updater.argoproj.io/image-list: weather-app=docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app
              argocd-image-updater.argoproj.io/weather-app.update-strategy: newest-build
              argocd-image-updater.argoproj.io/weather-app.allow-tags: regexp:^(good|bad)$
              argocd-image-updater.argoproj.io/write-back-method: git
              argocd-image-updater.argoproj.io/git-branch: main
              argocd-image-updater.argoproj.io/weather-app.git-credentials: image-updater-git-creds
              argocd-image-updater.argoproj.io/weather-app.helm.image-name: image.repository
              argocd-image-updater.argoproj.io/weather-app.helm.image-tag: image.tag
          spec:
            project: default
            source:
              repoURL: https://github.com/${{ github.repository }}
              targetRevision: main
              path: weather-app-helms
              helm:
                valueFiles: ["values.yaml"]
                parameters:
                - name: image.tag
                  value: good
            destination:
              server: https://kubernetes.default.svc
              namespace: helms
            syncPolicy:
              automated:
                selfHeal: true
                prune: true
          EOF

      # ✅ NEW STEP: Patch annotations every run (ensures good|bad are allowed)
      - name: Patch Application annotations
        run: |
          echo "📌 Ensuring Application is annotated with good|bad tag rules..."
          kubectl annotate application weather-app \
            argocd-image-updater.argoproj.io/weather-app.helm.allow-tags="regexp:^(good|bad)$" \
            --overwrite -n argocd

      # 10. Wait for initial application sync
      - name: Wait for initial application sync
        run: |
          echo "Waiting for application 'weather-app' to become Synced..."
          end_time=$((SECONDS + 300))
          while [ $SECONDS -lt $end_time ]; do
            sync_status=$(kubectl get application weather-app -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            
            if [ "$sync_status" = "Synced" ]; then
              echo "✅ Application is Synced! Proceeding with simulation."
              health_status=$(kubectl get application weather-app -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
              echo "Health status: $health_status"
              exit 0
            else
              echo "Current sync status: $sync_status. Waiting..."
              sleep 10
            fi
          done
          echo "⚠️ Timed out waiting for application to sync, but proceeding anyway for testing."

      # 11. Docker login
      - name: Docker login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 12. Build and push images with specific timestamps
      - name: Build & Push Images
        run: |
          # Build and push good image first
          docker build -t docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:good -f Dockerfile.good .
          docker push docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:good
          
          # Wait a bit to ensure different timestamps
          sleep 30
          
          # Build and push bad image (should be "newer")
          echo "FROM alpine:latest" > Dockerfile.bad
          echo 'CMD ["sh", "-c", "echo \"This is a bad container - failing immediately\"; exit 1"]' >> Dockerfile.bad
          docker build -t docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:bad -f Dockerfile.bad .
          docker push docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:bad

      # 13. Configure Image Updater registry access
      - name: Configure Image Updater registry access
        run: |
          # Delete existing secrets if they exist
          kubectl delete secret dockerhub-creds -n argocd --ignore-not-found
          kubectl delete secret dockerhub-creds -n helms --ignore-not-found
          
          # Create proper Docker registry secret in both namespaces
          for ns in argocd helms; do
            kubectl create secret docker-registry dockerhub-creds \
              --namespace=$ns \
              --docker-server=https://index.docker.io/v1/ \
              --docker-username=${{ secrets.DOCKERHUB_USERNAME }} \
              --docker-password=${{ secrets.DOCKERHUB_TOKEN }} \
              --dry-run=client -o yaml | kubectl apply -f -
          done
          
          # Create configmap for registry configuration (points to argocd/dockerhub-creds)
          kubectl apply -n argocd -f - <<EOF
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: argocd-image-updater-config
          data:
            registries.conf: |
              registries:
              - name: Docker Hub
                api_url: https://registry-1.docker.io
                prefix: docker.io
                ping: yes
                insecure: no
                credentials: pullsecret:argocd/dockerhub-creds
            commit.template: |
              build(docker): update image {{ .AppName }} to {{ .ImageAlias }}:{{ .ImageTag }}
              
              This is an automated commit from Argo CD Image Updater.
          EOF
          
          # Restart Image Updater to apply config
          kubectl rollout restart deployment argocd-image-updater -n argocd
          echo "✅ Image Updater configuration updated with proper pullsecret reference in both namespaces"
          sleep 15


      # 14. Trigger Image Updater to detect and deploy new images
      - name: Trigger ArgoCD Image Updater
        run: |
          echo "🔄 Triggering ArgoCD Image Updater to detect new images..."
          
          # Force Image Updater to scan for updates
          kubectl annotate application weather-app \
            argocd-image-updater.argoproj.io/force-update="$(date +%s)" \
            -n argocd --overwrite
          
          # Wait for Image Updater to process and write back to Git
          echo "⏳ Waiting for Image Updater to detect bad image and update Git..."
          TIMEOUT=300
          INTERVAL=15
          ELAPSED=0
          while true; do
            # Check if Image Updater has written back to Git
            git pull origin main
            CURRENT_TAG=$(grep 'tag:' weather-app-helms/values.yaml | awk '{print $2}' | tr -d '"' | tr -d "'")
            
            if [[ "$CURRENT_TAG" == "bad" ]]; then
              echo "✅ Image Updater detected bad image and updated Git to tag: $CURRENT_TAG"
              break
            fi
            
            if [[ $ELAPSED -ge $TIMEOUT ]]; then
              echo "❌ Timeout waiting for Image Updater to update Git"
              echo "Checking Image Updater logs..."
              kubectl logs -n argocd -l app.kubernetes.io/name=argocd-image-updater --tail=20
              exit 1
            fi
            
            echo "Current tag in Git: $CURRENT_TAG (waiting for 'bad')"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          # Wait for ArgoCD to sync the bad image
          echo "⏳ Waiting for ArgoCD to sync bad image deployment..."
          TIMEOUT=300
          INTERVAL=10
          ELAPSED=0
          while true; do
            CURRENT_IMAGE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.spec.template.spec.containers[0].image}" 2>/dev/null || echo "")
            if [[ "$CURRENT_IMAGE" == *":bad" ]]; then
              echo "✅ ArgoCD synced bad image deployment"
              break
            fi
            if [[ $ELAPSED -ge $TIMEOUT ]]; then
              echo "❌ Timeout waiting for bad deployment"
              exit 1
            fi
            echo "Waiting for bad deployment... (Current: $CURRENT_IMAGE)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          # Wait for bad image to fail
          echo "⏳ Waiting for bad image to fail..."
          FAIL_TIMEOUT=120
          FAIL_ELAPSED=0
          while true; do
            AVAILABLE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.status.availableReplicas}" 2>/dev/null || echo "0")
            if [[ "$AVAILABLE" -eq 0 ]]; then
              echo "✅ Bad image deployment failed as expected"
              break
            fi
            if [[ $FAIL_ELAPSED -ge $FAIL_TIMEOUT ]]; then
              echo "❌ Expected bad image to fail but it's still available"
              exit 1
            fi
            sleep 5
            FAIL_ELAPSED=$((FAIL_ELAPSED + 5))
          done
          
          # Now build and push good image again (should be newest)
          echo "🔄 Building and pushing good image again..."
          docker build -t docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:good -f Dockerfile.good .
          docker push docker.io/${{ secrets.DOCKERHUB_USERNAME }}/weather-app:good
          
          # Trigger Image Updater again to detect the new good image
          echo "🔄 Triggering Image Updater to detect good image..."
          kubectl annotate application weather-app \
            argocd-image-updater.argoproj.io/force-update="$(date +%s)" \
            -n argocd --overwrite
          
          # Wait for Image Updater to write back to Git
          echo "⏳ Waiting for Image Updater to update Git with good image..."
          TIMEOUT=300
          INTERVAL=15
          ELAPSED=0
          while true; do
            git pull origin main
            CURRENT_TAG=$(grep 'tag:' weather-app-helms/values.yaml | awk '{print $2}' | tr -d '"' | tr -d "'")
            
            if [[ "$CURRENT_TAG" == "good" ]]; then
              echo "✅ Image Updater detected good image and updated Git to tag: $CURRENT_TAG"
              break
            fi
            
            if [[ $ELAPSED -ge $TIMEOUT ]]; then
              echo "❌ Timeout waiting for Image Updater to update Git with good image"
              exit 1
            fi
            
            echo "Current tag in Git: $CURRENT_TAG (waiting for 'good')"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

      # 15. Verify final deployment
      - name: Verify final deployment
        run: |
          echo "⏳ Waiting for final deployment to become healthy..."
          TIMEOUT=300
          INTERVAL=10
          ELAPSED=0
          while true; do
            FINAL_IMAGE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.spec.template.spec.containers[0].image}" 2>/dev/null || echo "")
            AVAILABLE=$(kubectl get deployment weather-app -n helms -o jsonpath="{.status.availableReplicas}" 2>/dev/null || echo "0")
            
            if [[ "$FINAL_IMAGE" == *":good" ]] && [[ "$AVAILABLE" -eq 1 ]]; then
              echo "✅ SUCCESS: ArgoCD Image Updater successfully reconciled back to good image!"
              echo "✅ Final image: $FINAL_IMAGE"
              echo "✅ Available replicas: $AVAILABLE"
              break
            fi
            
            if [[ $ELAPSED -ge $TIMEOUT ]]; then
              echo "❌ FAILURE: Final reconciliation failed!"
              echo "❌ Image: $FINAL_IMAGE (expected *:good)"
              echo "❌ Available: $AVAILABLE (expected 1)"
              kubectl describe deployment weather-app -n helms
              exit 1
            fi
            
            echo "Waiting for final deployment... (Image: $FINAL_IMAGE, Available: $AVAILABLE)"
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          # Print final status
          echo "=== Final Deployment Status ==="
          kubectl get deployment weather-app -n helms -o wide
          echo "=== Pod Status ==="
          kubectl get pods -n helms -l app=weather-app -o wide

      # 16. Cleanup
      - name: Cleanup Kind cluster
        if: always()
        run: kind delete cluster --name argocd-cluster || true